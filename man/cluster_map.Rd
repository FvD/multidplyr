% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/cluster-call.R
\name{cluster_map}
\alias{cluster_map}
\alias{cluster_call}
\alias{cluster_walk}
\title{Call a function on each node of a cluster}
\usage{
cluster_map(.x, .f, ...)

cluster_call(x, code)

cluster_walk(x, code)
}
\arguments{
\item{.f}{Function to call. Must be a function, string, or formula.
   * If a **function**, it will be copied to each worke. Must be
     self-contained because its environment will be set to the global
     environment prior to being distributed to the workers.

   * If a **string**, the function will not be copied, and a function with
     that name will be called on each worker. Can use `::`.

   * If a **formula**, e.g. `~ .x + 2`, it is converted to a function.}

\item{...}{Arguments to .f. Eagerly evaluated before distribution.}

\item{x, .x}{A cluster}

\item{code}{An expression to execute on each worker.}
}
\value{
A list, with one element for each worker.
}
\description{
`cluster_map()` passes a function and arguments; `cluster_call()` quotes
the input and then re-calls; `cluster_walk()` is a version of
`cluster_call()` that doesn't return values. Jobs are submitted to workers
in parallel, and then we wait until they're complete.
}
\examples{
cl <- new_cluster(2)

# This function will be copied to each node
f <- function() 1 + 1
cl \%>\% cluster_map(f)

# The function will be called on each node
cl \%>\% cluster_map("Sys.getpid")

# cluster_call() provides a slightly simpler sytanx where you just
# provide an expression to be executed on each worke
cl \%>\% cluster_call(1 + 1)
cl \%>\% cluster_call(Sys.getpid())

invisible(cl \%>\% cluster_call(x <- runif(1)))
cl \%>\% cluster_call(x)
}
